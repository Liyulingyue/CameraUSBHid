<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å§¿åŠ¿å½•åˆ¶ä¸é…ç½® - å§¿æ€æ£€æµ‹ç³»ç»Ÿ</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.8;
            font-size: 1.1em;
        }

        .nav-links {
            text-align: center;
            margin-bottom: 30px;
        }

        .nav-links a {
            color: white;
            text-decoration: none;
            margin: 0 15px;
            padding: 10px 20px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            transition: background 0.3s ease;
        }

        .nav-links a:hover, .nav-links a.active {
            background: rgba(255, 255, 255, 0.2);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
        }

        .recording-section, .frames-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-placeholder {
            text-align: center;
            color: #666;
        }

        .preview-icon {
            font-size: 4em;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        .preview-placeholder p {
            margin: 5px 0;
            font-size: 1.1em;
        }

        .preview-placeholder small {
            opacity: 0.7;
        }

        #recording-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .recording-dot {
            width: 12px;
            height: 12px;
            background: #f44336;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .frames-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .frame-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            border: 3px solid transparent;
            transition: border-color 0.3s ease;
        }

        .frame-item.selected {
            border-color: #4CAF50;
        }

        .frame-item img {
            width: 100%;
            height: 100px;
            object-fit: cover;
            display: block;
        }

        .frame-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px;
            font-size: 0.8em;
            text-align: center;
        }

        .config-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            margin-top: 30px;
        }

        .form-label {
            color: white;
            font-weight: 500;
        }

        .form-control, .form-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
        }

        .form-select option {
            background: rgba(0, 0, 0, 0.8);
            color: white;
        }

        .form-control:focus, .form-select:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: #4CAF50;
            color: white;
            box-shadow: 0 0 0 0.2rem rgba(76, 175, 80, 0.25);
        }

        .form-control::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .keypoints-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.9em;
            max-height: 200px;
            overflow-y: auto;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-recording {
            background: #f44336;
            animation: pulse 1s infinite;
        }

        .status-processing {
            background: #ff9800;
            animation: pulse 1s infinite;
        }

        .status-ready {
            background: #4CAF50;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .pose-result-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .pose-canvas {
            max-width: 100%;
            border-radius: 4px;
        }

        .keypoints-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .keypoint-item {
            font-size: 0.8em;
        }

        /* å…³é”®ç‚¹è¡¨æ ¼æ ·å¼ */
        #keypoints-selector table {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(139, 195, 74, 0.1));
            border-radius: 8px;
            overflow: hidden;
        }

        #keypoints-selector thead {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
        }

        #keypoints-selector tbody tr:nth-child(even) {
            background: rgba(76, 175, 80, 0.05);
        }

        #keypoints-selector tbody tr:nth-child(odd) {
            background: rgba(139, 195, 74, 0.05);
        }

        #keypoints-selector tbody tr:hover {
            background: rgba(76, 175, 80, 0.15);
            transition: background 0.3s ease;
        }

        .pose-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .pose-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .pose-item:hover, .pose-item.selected {
            background: rgba(255, 255, 255, 0.1);
        }

        .pose-item .pose-name {
            font-weight: bold;
        }

        .pose-item .pose-index {
            font-size: 0.8em;
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .nav-links a {
                display: block;
                margin: 5px 0;
            }

            .frames-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¥ å§¿åŠ¿å½•åˆ¶ä¸é…ç½®</h1>
            <p>å½•åˆ¶è§†é¢‘ã€æå–å¸§ã€æ£€æµ‹å…³é”®ç‚¹ã€é…ç½®å§¿åŠ¿æ¨¡æ¿</p>
        </div>

        <div class="nav-links">
            <a href="/">ä¸»é¡µ</a>
            <a href="/realtime">å®æ—¶æ£€æµ‹</a>
            <a href="/mouse_control">é¼ æ ‡æ§åˆ¶</a>
            <a href="/pose_recorder" class="active">å§¿åŠ¿å½•åˆ¶</a>
        </div>

        <div class="main-content">
        <div class="recording-section">
            <h3>ğŸ“¹ è§†é¢‘å½•åˆ¶</h3>
            <div class="video-container">
                <video id="video-preview" autoplay muted style="display: none; max-width: 100%; max-height: 100%;"></video>
                <video id="recorded-video" controls style="display: none; max-width: 100%; max-height: 100%;"></video>
                <div id="no-camera" style="display: none; text-align: center; padding: 20px;">
                    <p>æ— æ³•è®¿é—®æ‘„åƒå¤´</p>
                    <p style="font-size: 0.9em; opacity: 0.7;">è¯·ç¡®ä¿å·²æˆäºˆæ‘„åƒå¤´æƒé™</p>
                </div>
                <div id="recording-indicator" style="display: none;">
                    <div class="recording-dot"></div>
                    <span>æ­£åœ¨å½•åˆ¶...</span>
                </div>
            </div>

            <div class="controls">
                <button id="start-record" class="btn btn-primary">å¼€å§‹å½•åˆ¶</button>
                <button id="stop-record" class="btn btn-danger" disabled>åœæ­¢å½•åˆ¶</button>
                <button id="process-video" class="btn btn-success" disabled>å¤„ç†å¸§</button>
                <div class="form-check form-switch ms-3" style="display:inline-block;">
                    <input class="form-check-input" type="checkbox" id="mirror-toggle">
                    <label class="form-check-label" for="mirror-toggle">é•œåƒæ˜¾ç¤º</label>
                </div>
            </div>

            <div class="recording-status">
                <span class="status-indicator" id="status-indicator"></span>
                <span id="status-text">å‡†å¤‡å°±ç»ª</span>
            </div>
        </div>            <div class="frames-section">
                <h3>ğŸ–¼ï¸ å¸§é¢„è§ˆ</h3>
                <div id="frames-container">
                    <p style="text-align: center; opacity: 0.7;">å½•åˆ¶å¹¶å¤„ç†è§†é¢‘åï¼Œå¸§å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</p>
                </div>

                <div class="mt-3">
                    <span class="ms-3">å·²é€‰æ‹©å¸§: <span id="selection-count">æ— </span></span>
                </div>
            </div>
        </div>

        <div class="config-panel">
            <h3>âš™ï¸ å§¿åŠ¿é…ç½®</h3>

            <div class="row">
                <div class="col-md-6">
                    <div class="mb-3">
                        <label for="existing-poses" class="form-label">é€‰æ‹©ç°æœ‰å§¿åŠ¿ (å¯é€‰)</label>
                        <select class="form-select" id="existing-poses">
                            <option value="">æ–°å»ºå§¿åŠ¿</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="pose-name" class="form-label">å§¿åŠ¿åç§°</label>
                        <input type="text" class="form-control" id="pose-name" placeholder="ä¾‹å¦‚: MyPose">
                    </div>
                    <div class="mb-3">
                        <label for="pose-index" class="form-label">å§¿åŠ¿ç´¢å¼•</label>
                        <input type="number" class="form-control" id="pose-index" placeholder="ä¾‹å¦‚: 15">
                    </div>
                    <div class="mb-3">
                        <label for="similarity-threshold" class="form-label">ç›¸ä¼¼åº¦é˜ˆå€¼</label>
                        <input type="number" class="form-control" id="similarity-threshold" step="0.01" min="0" max="1" value="0.95">
                    </div>
                    <div class="mb-3">
                        <label for="pose-img" class="form-label">å§¿åŠ¿å›¾ç‰‡ (å¯é€‰)</label>
                        <input type="text" class="form-control" id="pose-img" placeholder="ä¾‹å¦‚: MyPose.jpg">
                        <div class="form-text">å…³è”åˆ° Source/Images ç›®å½•ä¸‹çš„å›¾ç‰‡æ–‡ä»¶</div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="mb-3">
                        <label for="base-keypoint" class="form-label">åŸºå‡†å…³é”®ç‚¹</label>
                        <select class="form-select" id="base-keypoint">
                            <option value="nose">nose</option>
                            <option value="left_eye">left_eye</option>
                            <option value="right_eye">right_eye</option>
                            <option value="left_ear">left_ear</option>
                            <option value="right_ear">right_ear</option>
                            <option value="left_shoulder">left_shoulder</option>
                            <option value="right_shoulder">right_shoulder</option>
                            <option value="left_elbow">left_elbow</option>
                            <option value="right_elbow">right_elbow</option>
                            <option value="left_wrist">left_wrist</option>
                            <option value="right_wrist">right_wrist</option>
                            <option value="left_hip">left_hip</option>
                            <option value="right_hip">right_hip</option>
                            <option value="left_knee">left_knee</option>
                            <option value="right_knee">right_knee</option>
                            <option value="left_ankle">left_ankle</option>
                            <option value="right_ankle">right_ankle</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="keys-input" class="form-label">æ˜ å°„æŒ‰é”® (ç”¨é€—å·åˆ†éš”)</label>
                        <input type="text" class="form-control" id="keys-input" placeholder="ä¾‹å¦‚: w,a,s,d æˆ– space">
                    </div>
                    <div class="mb-3">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="inner-flag">
                            <label class="form-check-label" for="inner-flag">
                                å†…éƒ¨å§¿åŠ¿ (ä¸å‚ä¸å¸¸è§„æ£€æµ‹)
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="mb-3">
                <label class="form-label">æ ¸å¿ƒå…³é”®ç‚¹é€‰æ‹©</label>
                <div id="keypoints-selector"><!-- ç”±JSåŠ¨æ€ç”Ÿæˆè¡¨æ ¼ --></div>
            </div>

            <div class="mb-3">
                <label class="form-label">å§¿åŠ¿æ£€æµ‹ç»“æœ</label>
                <div id="pose-results">
                    æ£€æµ‹å§¿åŠ¿åå°†æ˜¾ç¤ºç»“æœ
                </div>
            </div>

            <div class="controls">
                <button id="save-pose" class="btn btn-success">ä¿å­˜å§¿åŠ¿</button>
                <button id="delete-pose" class="btn btn-danger" disabled>åˆ é™¤å§¿åŠ¿</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // å…¨å±€å˜é‡
        let mediaRecorder = null;
        let recordedChunks = [];
        let frames = [];
        let selectedFrames = new Set();
        let currentPoseData = null;
        let keypointsData = {};

        // å…³é”®ç‚¹åç§°æ˜ å°„
        const keypointNames = [
            'nose', 'left_eye', 'right_eye', 'left_ear', 'right_ear',
            'left_shoulder', 'right_shoulder', 'left_elbow', 'right_elbow',
            'left_wrist', 'right_wrist', 'left_hip', 'right_hip',
            'left_knee', 'right_knee', 'left_ankle', 'right_ankle'
        ];

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initializeCamera();
            setupEventListeners();
            loadExistingPoses();
            initializeKeypointsSelector();
        });

        // åˆå§‹åŒ–æ‘„åƒå¤´
        async function initializeCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 },
                    audio: false
                });
                document.getElementById('video-preview').srcObject = stream;
                document.getElementById('video-preview').style.display = 'block';
                updateStatus('å‡†å¤‡å°±ç»ª', 'ready');
            } catch (error) {
                console.error('æ— æ³•è®¿é—®æ‘„åƒå¤´:', error);
                document.getElementById('no-camera').style.display = 'block';
                updateStatus('æ— æ³•è®¿é—®æ‘„åƒå¤´', 'error');
            }
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            document.getElementById('start-record').addEventListener('click', startRecording);
            document.getElementById('stop-record').addEventListener('click', stopRecording);
            document.getElementById('process-video').addEventListener('click', processVideo);
            document.getElementById('save-pose').addEventListener('click', savePose);
            document.getElementById('delete-pose').addEventListener('click', deletePose);
            document.getElementById('existing-poses').addEventListener('change', loadSelectedPose);
        }

        // å¼€å§‹å½•åˆ¶
        function startRecording() {
            recordedChunks = [];
            const stream = document.getElementById('video-preview').srcObject;

            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9'
            });

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                document.getElementById('recorded-video').src = url;
                document.getElementById('recorded-video').style.display = 'block';
                document.getElementById('video-preview').style.display = 'none';
                updateStatus('å½•åˆ¶å®Œæˆ', 'ready');
                document.getElementById('process-video').disabled = false;
            };

            mediaRecorder.start();
            updateStatus('æ­£åœ¨å½•åˆ¶...', 'recording');
            document.getElementById('start-record').disabled = true;
            document.getElementById('stop-record').disabled = false;
        }

        // åœæ­¢å½•åˆ¶
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                document.getElementById('start-record').disabled = false;
                document.getElementById('stop-record').disabled = true;
            }
        }

        // å¤„ç†è§†é¢‘
        async function processVideo() {
            updateStatus('æ­£åœ¨å¤„ç†è§†é¢‘...', 'processing');
            document.getElementById('process-video').disabled = true;

            try {
                const video = document.getElementById('recorded-video');
                const duration = video.duration;
                const frameCount = Math.min(20, Math.floor(duration * 2)); // æœ€å¤š20å¸§

                frames = [];
                const framesContainer = document.getElementById('frames-container');
                framesContainer.innerHTML = '<div class="frames-grid" id="frames-grid"></div>';

                const framesGrid = document.getElementById('frames-grid');

                for (let i = 0; i < frameCount; i++) {
                    const time = (i / (frameCount - 1)) * duration;
                    video.currentTime = time;

                    await new Promise(resolve => {
                        video.onseeked = () => {
                            const canvas = document.createElement('canvas');
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                            const ctx = canvas.getContext('2d');
                            // æ ¹æ®é•œåƒåå¥½å†³å®šæ˜¯å¦é•œåƒç»˜åˆ¶å¸§åˆ°canvasï¼ˆå½±å“é€å¾€åç«¯çš„å›¾åƒå†…å®¹ï¼‰
                            const mirror = typeof getMirrorPreference === 'function' ? getMirrorPreference() : true;
                            if (mirror) {
                                ctx.save();
                                // å°†åŸç‚¹ç§»åŠ¨åˆ°å³è¾¹å†æ°´å¹³ç¿»è½¬ï¼Œå®ç°ç­‰æ•ˆçš„scaleX(-1)
                                ctx.translate(canvas.width, 0);
                                ctx.scale(-1, 1);
                                ctx.drawImage(video, 0, 0);
                                ctx.restore();
                            } else {
                                ctx.drawImage(video, 0, 0);
                            }

                            const frameData = {
                                index: i,
                                time: time,
                                imageData: canvas.toDataURL('image/jpeg', 0.8),
                                mirrored: (typeof getMirrorPreference === 'function') ? getMirrorPreference() : false
                            };
                            frames.push(frameData);

                            // åˆ›å»ºå¸§é¢„è§ˆ
                            const frameItem = document.createElement('div');
                            frameItem.className = 'frame-item';
                            frameItem.dataset.frameIndex = i;
                            frameItem.onclick = () => selectFrame(i);

                            const img = document.createElement('img');
                            img.src = frameData.imageData;
                            frameItem.appendChild(img);

                            const info = document.createElement('div');
                            info.className = 'frame-info';
                            info.textContent = `${i + 1}/${frameCount}`;
                            frameItem.appendChild(info);

                            framesGrid.appendChild(frameItem);
                            // åº”ç”¨é•œåƒåˆ°æ–°æ·»åŠ çš„å¸§é¢„è§ˆ
                            if (typeof refreshFramePreviewMirror === 'function') {
                                refreshFramePreviewMirror();
                            }
                            resolve();
                        };
                    });
                }

                updateStatus('è§†é¢‘å¤„ç†å®Œæˆï¼Œè¯·é€‰æ‹©åˆé€‚çš„å¸§', 'ready');
                document.getElementById('process-video').disabled = false;
                // å¤„ç†å®Œæˆåç»Ÿä¸€åˆ·æ–°ä¸€æ¬¡
                if (typeof refreshFramePreviewMirror === 'function') {
                    refreshFramePreviewMirror();
                }

            } catch (error) {
                console.error('å¤„ç†è§†é¢‘æ—¶å‡ºé”™:', error);
                updateStatus('å¤„ç†å¤±è´¥', 'error');
                document.getElementById('process-video').disabled = false;
            }
        }

        // å¤„ç†å¸§ï¼ˆæ˜¾ç¤ºå¸§é¢„è§ˆï¼‰
        function processFrames() {
            console.log('å¼€å§‹å¤„ç†å¸§ï¼Œå¸§æ•°é‡:', frames.length);
            console.log('å¸§æ•°æ®ç¤ºä¾‹:', frames[0]);
            
            if (frames.length === 0) {
                alert('æ²¡æœ‰å¯å¤„ç†çš„å¸§ï¼Œè¯·å…ˆå½•åˆ¶è§†é¢‘');
                return;
            }

            updateStatus('æ­£åœ¨ç”Ÿæˆå¸§é¢„è§ˆ...', 'processing');
            document.getElementById('process-video').disabled = true;

            const framesContainer = document.getElementById('frames-container');
            framesContainer.innerHTML = '<div class="frames-grid" id="frames-grid"></div>';

            const framesGrid = document.getElementById('frames-grid');

            frames.forEach((frameData, index) => {
                const frameItem = document.createElement('div');
                frameItem.className = 'frame-item';
                frameItem.dataset.frameIndex = index;

                const img = document.createElement('img');
                img.src = frameData.imageData;
                img.onload = () => {
                    console.log(`å¸§ ${index} åŠ è½½æˆåŠŸ`);
                    if (index === frames.length - 1) {
                        updateStatus('å¸§é¢„è§ˆç”Ÿæˆå®Œæˆï¼Œè¯·é€‰æ‹©åˆé€‚çš„å¸§', 'ready');
                    }
                };
                img.onerror = () => {
                    console.error(`å¸§ ${index} åŠ è½½å¤±è´¥`);
                };

                const info = document.createElement('div');
                info.className = 'frame-info';
                info.textContent = `${index + 1}/${frames.length}`;

                frameItem.appendChild(img);
                frameItem.appendChild(info);
                frameItem.onclick = () => selectFrame(index);

                framesGrid.appendChild(frameItem);
            });
        }

        // é€‰æ‹©å¸§
        function selectFrame(frameIndex) {
            console.log('é€‰æ‹©å¸§:', frameIndex);
            const frameItem = document.querySelector(`[data-frame-index="${frameIndex}"]`);
            console.log('æ‰¾åˆ°çš„å¸§å…ƒç´ :', frameItem);

            // å…ˆæ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.frame-item.selected').forEach(item => {
                item.classList.remove('selected');
            });
            selectedFrames.clear();

            // é€‰æ‹©å½“å‰å¸§
            selectedFrames.add(frameIndex);
            frameItem.classList.add('selected');
            console.log('é€‰æ‹©å¸§:', frameIndex);

            updateSelectedCount();

            // æ¸…ç©ºå·²æœ‰åæ ‡ï¼Œä»¥ä¾¿æ£€æµ‹ç»“æœèƒ½å†™å…¥ï¼ˆdetectå‡½æ•°åªå¡«ç©ºå­—æ®µï¼‰
            if (typeof clearAllKeypointInputs === 'function') {
                clearAllKeypointInputs();
            }

            // è‡ªåŠ¨æ£€æµ‹å…³é”®ç‚¹
            detectKeypointsForSelectedFrames();
        }

        // æ¸…ç©ºé€‰æ‹©
        function clearSelection() {
            selectedFrames.forEach(frameIndex => {
                const frameItem = document.querySelector(`[data-frame-index="${frameIndex}"]`);
                frameItem.classList.remove('selected');
            });
            selectedFrames.clear();
            updateSelectedCount();
        }

        // æ›´æ–°é€‰æ‹©è®¡æ•°
        function updateSelectedCount() {
            const count = selectedFrames.size;
            if (count === 0) {
                document.getElementById('selection-count').textContent = 'æ— ';
            } else {
                const frameIndex = Array.from(selectedFrames)[0];
                document.getElementById('selection-count').textContent = `å¸§ ${frameIndex + 1}`;
            }
        }

        // æ£€æµ‹å§¿åŠ¿
        async function detectPose() {
            console.log('æ£€æµ‹å§¿åŠ¿å‡½æ•°è¢«è°ƒç”¨');
            console.log('é€‰ä¸­çš„å¸§æ•°é‡:', selectedFrames.size);
            if (selectedFrames.size === 0) {
                alert('è¯·å…ˆé€‰æ‹©è¦æ£€æµ‹çš„å¸§');
                return;
            }

            updateStatus('æ­£åœ¨æ£€æµ‹å§¿åŠ¿...', 'processing');
            document.getElementById('detect-pose').disabled = true;

            try {
                console.log('å¼€å§‹è°ƒç”¨detectKeypointsForSelectedFrames');
                await detectKeypointsForSelectedFrames();
                console.log('detectKeypointsForSelectedFrameså®Œæˆ');
                updateStatus('å§¿åŠ¿æ£€æµ‹å®Œæˆ', 'ready');
            } catch (error) {
                console.error('å§¿åŠ¿æ£€æµ‹å¤±è´¥:', error);
                updateStatus('å§¿åŠ¿æ£€æµ‹å¤±è´¥', 'error');
            } finally {
                document.getElementById('detect-pose').disabled = false;
            }
        }

        // ä¸ºé€‰ä¸­çš„å¸§æ£€æµ‹å…³é”®ç‚¹
        async function detectKeypointsForSelectedFrames() {
            const selectedFrameIndices = Array.from(selectedFrames);
            const frameData = selectedFrameIndices.map(index => frames[index]);

            console.log('å‘é€ç»™APIçš„å¸§æ•°æ®:', frameData);

            try {
                const response = await fetch('/api/detect_keypoints_batch', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ frames: frameData })
                });

                const result = await response.json();
                console.log('APIå“åº”:', result);

                if (result.success && result.keypoints) {
                    keypointsData = result.keypoints;
                    console.log('è®¾ç½®keypointsData:', keypointsData);

                    // ä»…å–å½“å‰é€‰ä¸­çš„å•å¸§ï¼ˆæˆ‘ä»¬å¼ºåˆ¶å•é€‰å¸§ï¼‰
                    const frameIndex = Array.from(selectedFrames)[0];
                    const detected = keypointsData[frameIndex];
                    if (detected) {
                        // å¡«å……åæ ‡ï¼ˆåªå¡«å……ç©ºçš„å­—æ®µï¼‰
                        keypointNames.forEach(name => {
                            const vals = detected[name];
                            const xEl = document.getElementById(`kp-${name}-x`);
                            const yEl = document.getElementById(`kp-${name}-y`);
                            if (vals && xEl && yEl) {
                                const [x, y] = vals;
                                // åªåœ¨å­—æ®µä¸ºç©ºæ—¶å¡«å……æ¨ç†ç»“æœ
                                if (xEl.value.trim() === '') {
                                    xEl.value = Number.isFinite(x) ? x.toFixed(2) : '';
                                }
                                if (yEl.value.trim() === '') {
                                    yEl.value = Number.isFinite(y) ? y.toFixed(2) : '';
                                }
                            }
                        });

                        // åœ¨ç»“æœåŒºåŸŸç”»å‡ºå¸¦å…³é”®ç‚¹çš„å›¾ç‰‡
                        renderPosePreview(frameIndex, detected);
                    }
                } else {
                    console.error('APIè¿”å›å¤±è´¥:', result);
                    alert('å…³é”®ç‚¹æ£€æµ‹å¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'));
                }

            } catch (error) {
                console.error('å…³é”®ç‚¹æ£€æµ‹å¤±è´¥:', error);
                alert('å…³é”®ç‚¹æ£€æµ‹å¤±è´¥: ' + error.message);
            }
        }

        // åˆå§‹åŒ–å…³é”®ç‚¹é€‰æ‹©å™¨ï¼ˆè¡¨æ ¼ï¼šå¤šé€‰å¤é€‰æ¡†+åç§°+X/Yï¼‰
        function initializeKeypointsSelector() {
            const container = document.getElementById('keypoints-selector');
            container.innerHTML = '';

            const table = document.createElement('table');
            table.className = 'table table-dark table-striped';

            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr>
                    <th scope="col">é€‰æ‹©</th>
                    <th scope="col">å…³é”®ç‚¹åç§°</th>
                    <th scope="col">X åæ ‡</th>
                    <th scope="col">Y åæ ‡</th>
                </tr>
            `;
            table.appendChild(thead);

            const tbody = document.createElement('tbody');

            keypointNames.forEach(name => {
                const tr = document.createElement('tr');

                const tdSelect = document.createElement('td');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.name = 'core-keypoint';
                checkbox.id = `kp-${name}`;
                checkbox.value = name;
                checkbox.className = 'form-check-input';
                tdSelect.appendChild(checkbox);

                const tdName = document.createElement('td');
                tdName.textContent = name;

                const tdX = document.createElement('td');
                const inputX = document.createElement('input');
                inputX.type = 'text';
                inputX.id = `kp-${name}-x`;
                inputX.className = 'form-control';
                tdX.appendChild(inputX);

                const tdY = document.createElement('td');
                const inputY = document.createElement('input');
                inputY.type = 'text';
                inputY.id = `kp-${name}-y`;
                inputY.className = 'form-control';
                tdY.appendChild(inputY);

                tr.appendChild(tdSelect);
                tr.appendChild(tdName);
                tr.appendChild(tdX);
                tr.appendChild(tdY);
                tbody.appendChild(tr);
            });

            table.appendChild(tbody);
            container.appendChild(table);
        }

        // æ¸…ç©ºæ‰€æœ‰å…³é”®ç‚¹è¾“å…¥æ¡†ï¼ˆä¸æ”¹å˜å¤é€‰æ¡†çš„é€‰ä¸­çŠ¶æ€ï¼‰
        function clearAllKeypointInputs() {
            keypointNames.forEach(name => {
                const xEl = document.getElementById(`kp-${name}-x`);
                const yEl = document.getElementById(`kp-${name}-y`);
                if (xEl) xEl.value = '';
                if (yEl) yEl.value = '';
            });
        }

        // ä¿å­˜å§¿åŠ¿
        async function savePose() {
            const poseName = document.getElementById('pose-name').value.trim();
            const poseIndex = parseInt(document.getElementById('pose-index').value);
            const similarityThreshold = parseFloat(document.getElementById('similarity-threshold').value);
            const baseKeypoint = document.getElementById('base-keypoint').value;
            const keysInput = document.getElementById('keys-input').value.trim();
            const innerFlag = document.getElementById('inner-flag').checked;
            const poseImg = document.getElementById('pose-img').value.trim();

            if (!poseName || isNaN(poseIndex)) {
                alert('è¯·å¡«å†™å§¿åŠ¿åç§°å’Œç´¢å¼•');
                return;
            }

            // è·å–é€‰ä¸­çš„æ ¸å¿ƒå…³é”®ç‚¹ï¼ˆå¤šé€‰ï¼‰
            const selectedKeypoints = Array.from(document.querySelectorAll('#keypoints-selector input[type="checkbox"][name="core-keypoint"]:checked'))
                .map(cb => cb.value);

            if (selectedKeypoints.length === 0) {
                alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ ¸å¿ƒå…³é”®ç‚¹');
                return;
            }

            // è®¡ç®—ç›¸å¯¹å…³é”®ç‚¹æ•°æ®ï¼ˆcore - baseï¼‰
            let avgKeypoints;
            try {
                avgKeypoints = calculateAverageKeypoints(selectedKeypoints);
            } catch (e) {
                alert(e.message || 'å…³é”®ç‚¹è®¡ç®—å¤±è´¥');
                return;
            }

            const poseData = {
                name: poseName,
                index: poseIndex,
                inner_flag: innerFlag,
                similarity_threshold: similarityThreshold,
                keys: keysInput ? keysInput.split(',').map(k => k.trim()) : [],
                basekeypoints: baseKeypoint,
                list_corekeypoints: selectedKeypoints,
                value_dict: avgKeypoints,
                pose_img: poseImg
            };

            try {
                const response = await fetch('/api/save_pose', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(poseData)
                });

                const result = await response.json();
                if (result.success) {
                    alert('å§¿åŠ¿ä¿å­˜æˆåŠŸï¼');
                    loadExistingPoses(); // é‡æ–°åŠ è½½å§¿åŠ¿åˆ—è¡¨
                } else {
                    alert('ä¿å­˜å¤±è´¥: ' + result.message);
                }
            } catch (error) {
                console.error('ä¿å­˜å§¿åŠ¿å¤±è´¥:', error);
                alert('ä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—');
            }
        }

        // è®¡ç®—ç›¸å¯¹å…³é”®ç‚¹æ•°æ®ï¼švalue_dict = core_keypoint - basekeypoint
        // éœ€æ±‚ï¼š
        // - è‹¥åŸºå‡†ç‚¹æœªå¡«å†™ï¼Œåˆ™æŒ‰ 0 å¤„ç†
        // - è‹¥æ ¸å¿ƒç‚¹æœªå¡«å†™ï¼Œåˆ™ç›¸å¯¹é‡æŒ‰ [0,0] ä¿å­˜ï¼Œç¡®ä¿ä¸€è‡´
        function calculateAverageKeypoints(selectedKeypoints) {
            const result = {};

            const base = document.getElementById('base-keypoint').value;
            const bxStr = document.getElementById(`kp-${base}-x`).value.trim();
            const byStr = document.getElementById(`kp-${base}-y`).value.trim();

            let bx = 0, by = 0;
            if (bxStr !== '' && byStr !== '') {
                const tbx = parseFloat(bxStr);
                const tby = parseFloat(byStr);
                if (Number.isFinite(tbx) && Number.isFinite(tby)) {
                    bx = tbx; by = tby;
                }
            }

            selectedKeypoints.forEach(kp => {
                const xStr = document.getElementById(`kp-${kp}-x`).value.trim();
                const yStr = document.getElementById(`kp-${kp}-y`).value.trim();
                if (xStr === '' || yStr === '') {
                    // æœªå¡«å†™åˆ™ç›¸å¯¹é‡æŒ‰ 0 å¤„ç†
                    result[kp] = [0, 0];
                    return;
                }
                const x = parseFloat(xStr);
                const y = parseFloat(yStr);
                if (!Number.isFinite(x) || !Number.isFinite(y)) {
                    // éæ³•åˆ™æŒ‰ 0 å¤„ç†
                    result[kp] = [0, 0];
                    return;
                }
                // core - base
                result[kp] = [x - bx, y - by];
            });

            return result;
        }

        // åŠ è½½ç°æœ‰å§¿åŠ¿åˆ°ä¸‹æ‹‰æ¡†
        async function loadExistingPoses() {
            try {
                const response = await fetch('/static/configs.json');
                const poses = await response.json();
                const select = document.getElementById('existing-poses');
                select.innerHTML = '<option value="">æ–°å»ºå§¿åŠ¿</option>';
                poses.forEach(pose => {
                    const option = document.createElement('option');
                    option.value = pose.index; // ä½¿ç”¨indexä½œä¸ºå”¯ä¸€æ ‡è¯†ç¬¦
                    option.textContent = pose.name;
                    option.dataset.poseImg = pose.pose_img || ''; // å­˜å‚¨å§¿åŠ¿å›¾ç‰‡ä¿¡æ¯
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('åŠ è½½å§¿åŠ¿åˆ—è¡¨å¤±è´¥:', error);
            }
        }

        // åŠ è½½é€‰ä¸­çš„å§¿åŠ¿
        async function loadSelectedPose() {
            const select = document.getElementById('existing-poses');
            const poseIndex = parseInt(select.value);
            if (!poseIndex && poseIndex !== 0) {
                // æ¸…ç©ºè¡¨å•
                document.getElementById('pose-name').value = '';
                document.getElementById('pose-index').value = '';
                document.getElementById('similarity-threshold').value = '0.95';
                document.getElementById('base-keypoint').value = 'nose';
                document.getElementById('keys-input').value = '';
                document.getElementById('inner-flag').checked = false;
                document.getElementById('pose-img').value = '';
                
                // æ¸…ç©ºæ ¸å¿ƒå…³é”®ç‚¹é€‰æ‹©å’Œåæ ‡
                document.querySelectorAll('#keypoints-selector input[type="checkbox"][name="core-keypoint"]').forEach(cb => {
                    cb.checked = false;
                });
                keypointNames.forEach(name => {
                    const xEl = document.getElementById(`kp-${name}-x`);
                    const yEl = document.getElementById(`kp-${name}-y`);
                    if (xEl) xEl.value = '';
                    if (yEl) yEl.value = '';
                });
                
                document.getElementById('delete-pose').disabled = true;
                return;
            }

            try {
                const response = await fetch('/static/configs.json');
                const poses = await response.json();
                const pose = poses.find(p => p.index === poseIndex);

                if (pose) {
                    // å…ˆæ¸…ç©ºæ‰€æœ‰å…³é”®ç‚¹è¾“å…¥ï¼Œé¿å…æ®‹ç•™å€¼é˜»æ­¢åç»­åˆ·æ–°
                    if (typeof clearAllKeypointInputs === 'function') {
                        clearAllKeypointInputs();
                    }

                    document.getElementById('pose-name').value = pose.name || '';
                    document.getElementById('pose-index').value = pose.index || '';
                    document.getElementById('similarity-threshold').value = pose.similarity_threshold || '0.95';
                    document.getElementById('base-keypoint').value = pose.basekeypoints || 'nose';
                    document.getElementById('keys-input').value = pose.keys ? pose.keys.join(',') : '';
                    document.getElementById('inner-flag').checked = pose.inner_flag || false;
                    document.getElementById('pose-img').value = pose.pose_img || '';

                    // æ¢å¤æ ¸å¿ƒå…³é”®ç‚¹ï¼ˆå¤šé€‰ï¼‰
                    const coreList = pose.list_corekeypoints || [];
                    document.querySelectorAll('#keypoints-selector input[type="checkbox"][name="core-keypoint"]').forEach(cb => {
                        cb.checked = coreList.includes(cb.value);
                    });

                    // å°†ç›¸å¯¹åæ ‡è½¬æ¢ä¸ºç»å¯¹åæ ‡æ˜¾ç¤ºï¼šabs = rel + base
                    if (pose.value_dict) {
                        const baseName = pose.basekeypoints || 'nose';
                        const bxEl = document.getElementById(`kp-${baseName}-x`);
                        const byEl = document.getElementById(`kp-${baseName}-y`);
                        let bx = 0, by = 0;
                        if (bxEl && bxEl.value !== '' && byEl && byEl.value !== '') {
                            const tbx = parseFloat(bxEl.value);
                            const tby = parseFloat(byEl.value);
                            if (Number.isFinite(tbx) && Number.isFinite(tby)) { bx = tbx; by = tby; }
                        }

                        // éå†å½“å‰å·²çŸ¥çš„æ ¸å¿ƒç‚¹é›†åˆï¼ˆæ¥è‡ª pose.list_corekeypointsï¼‰
                        const coreList = pose.list_corekeypoints || Object.keys(pose.value_dict);
                        coreList.forEach(keypointName => {
                            const rel = pose.value_dict[keypointName] || [0, 0];
                            const xEl = document.getElementById(`kp-${keypointName}-x`);
                            const yEl = document.getElementById(`kp-${keypointName}-y`);
                            if (xEl && yEl && Array.isArray(rel) && rel.length >= 2) {
                                const rx = Number.isFinite(rel[0]) ? rel[0] : 0;
                                const ry = Number.isFinite(rel[1]) ? rel[1] : 0;
                                xEl.value = (bx + rx).toFixed(2);
                                yEl.value = (by + ry).toFixed(2);
                            }
                        });
                    }

                    updateStatus('å§¿åŠ¿åŠ è½½æˆåŠŸ', 'ready');
                    document.getElementById('delete-pose').disabled = false;
                } else {
                    updateStatus('æœªæ‰¾åˆ°æŒ‡å®šçš„å§¿åŠ¿', 'error');
                    document.getElementById('delete-pose').disabled = true;
                    // æ¸…ç©ºåæ ‡å­—æ®µ
                    keypointNames.forEach(name => {
                        const xEl = document.getElementById(`kp-${name}-x`);
                        const yEl = document.getElementById(`kp-${name}-y`);
                        if (xEl) xEl.value = '';
                        if (yEl) yEl.value = '';
                    });
                }
            } catch (error) {
                console.error('åŠ è½½å§¿åŠ¿å¤±è´¥:', error);
                updateStatus('åŠ è½½å¤±è´¥', 'error');
                document.getElementById('delete-pose').disabled = true;
                // æ¸…ç©ºåæ ‡å­—æ®µ
                keypointNames.forEach(name => {
                    const xEl = document.getElementById(`kp-${name}-x`);
                    const yEl = document.getElementById(`kp-${name}-y`);
                    if (xEl) xEl.value = '';
                    if (yEl) yEl.value = '';
                });
            }
        }

        // åˆ é™¤å§¿åŠ¿
        async function deletePose() {
            const select = document.getElementById('existing-poses');
            const poseIndex = parseInt(select.value);
            if (!Number.isInteger(poseIndex)) {
                alert('è¯·å…ˆä»åˆ—è¡¨ä¸­é€‰æ‹©è¦åˆ é™¤çš„å§¿åŠ¿');
                return;
            }

            if (!confirm(`ç¡®å®šè¦åˆ é™¤ç´¢å¼•ä¸º ${poseIndex} çš„å§¿åŠ¿å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`)) {
                return;
            }

            try {
                const response = await fetch('/api/delete_pose', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ index: poseIndex })
                });
                const result = await response.json();
                if (result.success) {
                    alert('åˆ é™¤æˆåŠŸ');
                    await loadExistingPoses();
                    // é‡ç½®é€‰æ‹©ä¸ºâ€œæ–°å»ºå§¿åŠ¿â€
                    document.getElementById('existing-poses').value = '';
                    await loadSelectedPose();
                } else {
                    alert('åˆ é™¤å¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (err) {
                console.error('åˆ é™¤å§¿åŠ¿å¤±è´¥:', err);
                alert('åˆ é™¤å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—');
            }
        }

        // è¯»å–å’Œä¿å­˜é•œåƒåå¥½
        function getMirrorPreference() {
            const v = localStorage.getItem('pose_mirror_enabled');
            return v === null ? true : v === 'true'; // é»˜è®¤å¼€å¯
        }

        function setMirrorPreference(enabled) {
            localStorage.setItem('pose_mirror_enabled', enabled ? 'true' : 'false');
        }

        // åº”ç”¨é•œåƒåˆ°è§†é¢‘å…ƒç´ 
        function applyMirrorToVideos(enabled) {
            const preview = document.getElementById('video-preview');
            const recorded = document.getElementById('recorded-video');
            const t = enabled ? 'scaleX(-1)' : 'none';
            if (preview) preview.style.transform = t;
            if (recorded) recorded.style.transform = t;
        }

        // åº”ç”¨é•œåƒåˆ°å¸§é¢„è§ˆå®¹å™¨
        function applyMirrorToFrames(enabled) {
            // æ³¨æ„ï¼šå¸§å›¾åƒæ•°æ®åœ¨æŠ“å–é˜¶æ®µå·²æ ¹æ®åå¥½è¿›è¡Œé•œåƒç»˜åˆ¶
            // è¿™é‡Œä¸å†å¯¹é¢„è§ˆimgåšCSSé•œåƒï¼Œé¿å…åŒé‡é•œåƒå¯¼è‡´æ–¹å‘é”™è¯¯
        }

        // åˆå§‹åŒ–å¼€å…³å’Œç›‘å¬
        document.addEventListener('DOMContentLoaded', () => {
            const mirrorToggle = document.getElementById('mirror-toggle');
            const enabled = getMirrorPreference();
            if (mirrorToggle) {
                mirrorToggle.checked = enabled;
                mirrorToggle.addEventListener('change', () => {
                    const en = mirrorToggle.checked;
                    setMirrorPreference(en);
                    applyMirrorToVideos(en);
                    applyMirrorToFrames(en);
                    // è‹¥å·²æœ‰å½•åˆ¶è§†é¢‘ï¼Œåˆ‡æ¢é•œåƒåè‡ªåŠ¨é‡æ–°å¤„ç†å¸§ä»¥åº”ç”¨æ–°æ–¹å‘
                    const recorded = document.getElementById('recorded-video');
                    if (recorded && recorded.src) {
                        // æ¸…ç©ºå·²æœ‰å¸§
                        const framesContainer = document.getElementById('frames-container');
                        if (framesContainer) framesContainer.innerHTML = '<p style="text-align: center; opacity: 0.7;">æ­£åœ¨æ ¹æ®æ–°æ–¹å‘é‡æ–°ç”Ÿæˆå¸§...</p>';
                        // é‡æ–°å¤„ç†
                        setTimeout(() => { processVideo(); }, 50);
                    }
                });
            }
            applyMirrorToVideos(enabled);
        });

        // åœ¨å¤„ç†å®Œå¸§å¹¶åˆ›å»ºé¢„è§ˆåè°ƒç”¨ä¸€æ¬¡
        function refreshFramePreviewMirror() {
            const enabled = getMirrorPreference();
            applyMirrorToFrames(enabled);
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus(text, status) {
            document.getElementById('status-text').textContent = text;
            const indicator = document.getElementById('status-indicator');

            indicator.className = 'status-indicator';
            if (status === 'recording') {
                indicator.classList.add('status-recording');
            } else if (status === 'processing') {
                indicator.classList.add('status-processing');
            } else if (status === 'ready') {
                indicator.classList.add('status-ready');
            }
        }

        // åœ¨ç»“æœåŒºåŸŸæ¸²æŸ“å…³é”®ç‚¹ï¼ˆä½¿ç”¨APIç»˜åˆ¶ï¼‰
        async function renderPosePreview(frameIndex, keypoints) {
            const resultDiv = document.getElementById('pose-results');
            resultDiv.innerHTML = '';

            const wrapper = document.createElement('div');
            wrapper.className = 'pose-result-item';

            // è·å–å½“å‰é€‰ä¸­çš„å§¿åŠ¿å›¾ç‰‡
            const select = document.getElementById('existing-poses');
            const poseIndex = parseInt(select.value);
            let poseImgSrc = null;

            if (!isNaN(poseIndex)) {
                // ä»å·²åŠ è½½çš„å§¿åŠ¿åˆ—è¡¨ä¸­æŸ¥æ‰¾
                const selectedOption = select.options[select.selectedIndex];
                if (selectedOption && selectedOption.dataset && selectedOption.dataset.poseImg) {
                    poseImgSrc = selectedOption.dataset.poseImg;
                }
            }

            // è§£æå§¿åŠ¿å›¾ç‰‡è·¯å¾„ï¼Œå…¼å®¹ä»¥ä¸‹è¾“å…¥ï¼š
            // - "MyPose.jpg"
            // - "Images/MyPose.jpg"
            // - "Source/Images/MyPose.jpg"
            // - "/static/Images/MyPose.jpg"
            function resolvePoseImageUrl(src) {
                if (!src) return null;
                let s = String(src).trim();
                if (s.startsWith('/static/')) return s; // å·²æ˜¯é™æ€è·¯å¾„
                if (s.startsWith('Source/Images/')) {
                    s = s.substring('Source/Images/'.length).trim();
                } else if (s.startsWith('Images/')) {
                    s = s.substring('Images/'.length).trim();
                } else if (s.includes('/')) {
                    // å…œåº•ï¼šåªå–æ–‡ä»¶åéƒ¨åˆ†
                    const parts = s.split('/');
                    s = parts[parts.length - 1].trim();
                }
                return `/static/Images/${s}`;
            }

            // å¦‚æœæœ‰å§¿åŠ¿å›¾ç‰‡ï¼Œå…ˆæ˜¾ç¤ºå›¾ç‰‡
            if (poseImgSrc) {
                const poseImg = document.createElement('img');
                poseImg.src = resolvePoseImageUrl(poseImgSrc);
                poseImg.className = 'pose-reference-img';
                poseImg.style.maxWidth = '200px';
                poseImg.style.maxHeight = '150px';
                poseImg.style.marginBottom = '10px';
                poseImg.style.border = '2px solid #4CAF50';
                poseImg.style.borderRadius = '5px';
                poseImg.onerror = () => {
                    console.warn(`æ— æ³•åŠ è½½å§¿åŠ¿å›¾ç‰‡: ${poseImgSrc}`);
                    poseImg.style.display = 'none';
                };
                wrapper.appendChild(poseImg);
            }

            try {
                // è°ƒç”¨APIè·å–ç»˜åˆ¶äº†å…³é”®ç‚¹çš„å›¾åƒ
                const response = await fetch('/api/render_keypoints', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ frame: frames[frameIndex] })
                });

                const result = await response.json();
                
                if (result.success && result.imageData) {
                    const keypointsImg = document.createElement('img');
                    keypointsImg.src = result.imageData;
                    keypointsImg.className = 'pose-canvas';
                    keypointsImg.style.maxWidth = '100%';
                    keypointsImg.style.height = 'auto';
                    wrapper.appendChild(keypointsImg);
                } else {
                    // å¦‚æœAPIè°ƒç”¨å¤±è´¥ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                    const errorDiv = document.createElement('div');
                    errorDiv.textContent = 'å…³é”®ç‚¹æ¸²æŸ“å¤±è´¥';
                    errorDiv.style.color = 'red';
                    errorDiv.style.padding = '20px';
                    errorDiv.style.textAlign = 'center';
                    wrapper.appendChild(errorDiv);
                }
            } catch (error) {
                console.error('æ¸²æŸ“å…³é”®ç‚¹æ—¶å‡ºé”™:', error);
                const errorDiv = document.createElement('div');
                errorDiv.textContent = 'å…³é”®ç‚¹æ¸²æŸ“å‡ºé”™';
                errorDiv.style.color = 'red';
                errorDiv.style.padding = '20px';
                errorDiv.style.textAlign = 'center';
                wrapper.appendChild(errorDiv);
            }

            resultDiv.appendChild(wrapper);
        }
    </script>
</body>
</html>